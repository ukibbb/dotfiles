#!/usr/bin/env bash
# =============================================================================
# launcher - Główny punkt wejścia dla Project Launcher
# =============================================================================
# Ten skrypt orchestruje cały proces uruchamiania projektu:
#   1. Skanuje system plików w poszukiwaniu projektów
#   2. Wyświetla fzf do wyboru projektu
#   3. Uruchamia projekt w domyślnym trybie
#
# Użycie:
#   ./launcher                           - Interaktywny tryb (fzf)
#   ./launcher <project_path>            - Pomiń wybór projektu
#   ./launcher <project_path> <mode>     - Pomiń wybór projektu i użyj określonego trybu
#
# Zależności:
#   - fzf (fuzzy finder)
#   - Ghostty (terminal)
#   - tmux (opcjonalnie, dla trybów z tmux)
# =============================================================================

# Włącz strict mode dla bezpieczeństwa
# -e = zakończ przy pierwszym błędzie
# -u = traktuj niezdefiniowane zmienne jako błąd
# -o pipefail = propaguj błędy w pipeline
set -euo pipefail

# =============================================================================
# KONFIGURACJA - Ścieżki i zmienne globalne
# =============================================================================

# Co robi ten kod?
# Kod ten służy do ustalenia lokalizacji (ścieżki) katalogu, w którym znajduje się uruchamiany skrypt (launcher).
# Jeśli skrypt został uruchomiony poprzez symlink (link symboliczny), kod znajduje "prawdziwy" docelowy plik i ustawia zmienną SCRIPT_DIR na jego katalog.
#
# Co to jest symlink (link symboliczny)?
# Symlink (symbolic link) to specjalny rodzaj pliku w systemach Unix/Linux, który działa jak skrót - wskazuje na inny plik lub katalog w systemie plików.
# Dzięki symlinkom można np. umieścić skrypt w jednym miejscu, a stworzyć do niego odwołanie w innym (np. w katalogu na PATH), bez kopiowania pliku.

# Pobierz ścieżkę do katalogu, obsługując możliwość, że skrypt jest symlinkiem
SOURCE="${BASH_SOURCE[0]}"
while [ -L "$SOURCE" ]; do
  TARGET="$(readlink "$SOURCE")"
  if [[ $TARGET == /* ]]; then
    SOURCE="$TARGET"
  else
    DIR="$(dirname "$SOURCE")"
    SOURCE="$DIR/$TARGET"
  fi
done
SCRIPT_DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"

# Ścieżka do katalogu lib/ z pomocniczymi skryptami
LIB_DIR="$SCRIPT_DIR/lib"

# Ścieżki do poszczególnych komponentów
FIND_PROJECTS_SCRIPT="$LIB_DIR/find-projects.sh"              # Skrypt skanujący system
LAUNCH_PROJECT_SCRIPT="$LIB_DIR/launch-project.sh"            # Skrypt uruchamiający projekt

# Domyślny tryb uruchomienia
DEFAULT_MODE="tmux-nvim-claude"

# FUNKCJA: check_dependencies
# Sprawdza czy wszystkie wymagane narzędzia są zainstalowane.
# Jeśli brakuje krytycznego narzędzia, wypisuje błąd i kończy skrypt.
# =============================================================================
check_dependencies() {
    # Tablica z wymaganymi komendami
    # Każdy element to: "nazwa_komendy|opis|czy_opcjonalna"
    local deps=(
        "fzf|Fuzzy finder - do wyboru projektu|false"
    )

    # Flaga czy znaleziono jakiś brakujący dependency
    local missing=false

    # Iteruj po każdym dependency
    for dep in "${deps[@]}"; do
        # Rozdziel string po | na 3 części
        # IFS='|' = separator to |
        # read -r = czytaj bez escape'owania
        IFS='|' read -r cmd desc optional <<< "$dep"

        # Sprawdź czy komenda jest dostępna w PATH
        # command -v = zwraca ścieżkę do komendy jeśli istnieje
        # &>/dev/null = ignoruj output
        if ! command -v "$cmd" &>/dev/null; then
            # Komenda NIE jest dostępna
            if [[ "$optional" == "false" ]]; then
                # To jest wymagany dependency - wypisz błąd
                echo "BŁĄD: Brakuje wymaganego narzędzia: $cmd" >&2
                echo "       $desc" >&2
                missing=true
            else
                # To jest opcjonalny dependency - tylko ostrzeżenie
                echo "OSTRZEŻENIE: Brakuje opcjonalnego narzędzia: $cmd" >&2
                echo "             $desc" >&2
            fi
        fi
    done

    # Jeśli brakowało jakiegoś wymaganego dependency, zakończ
    if [[ "$missing" == true ]]; then
        echo "" >&2
        echo "Zainstaluj brakujące narzędzia i spróbuj ponownie." >&2
        echo "Możesz użyć: brew install fzf" >&2
        exit 1
    fi
}

# =============================================================================
# FUNKCJA: select_project
# =============================================================================
# Pozwala użytkownikowi wybrać projekt używając fzf.
# Wywołuje find-projects.sh aby uzyskać listę katalogów, a następnie
# przekazuje ją do fzf.
#
# Zwraca (stdout): Pełną ścieżkę do wybranego projektu
# Exit code: 0 = sukces, 1 = anulowano
# =============================================================================
select_project() {
    # Sprawdź czy skrypt find-projects.sh istnieje
    if [[ ! -f "$FIND_PROJECTS_SCRIPT" ]]; then
        echo "BŁĄD: Nie znaleziono skryptu: $FIND_PROJECTS_SCRIPT" >&2
        exit 1
    fi

    # Nadaj uprawnienia wykonywania skryptowi (na wszelki wypadek)
    chmod +x "$FIND_PROJECTS_SCRIPT"

    echo "Skanowanie katalogów..." >&2

    # Wywołaj skrypt skanujący i zapisz wynik do zmiennej
    # $(...) = command substitution (wykonaj komendę i wstaw jej output)
    local projects_list
    projects_list=$("$FIND_PROJECTS_SCRIPT")

    # Sprawdź czy lista nie jest pusta
    if [[ -z "$projects_list" ]]; then
        echo "BŁĄD: Nie znaleziono żadnych katalogów" >&2
        exit 1
    fi

    echo "Wybierz projekt:" >&2

    # Przekaż listę do fzf i pozwól użytkownikowi wybrać
    # echo "$projects_list" = wypisz listę (każda ścieżka w osobnej linii)
    # | fzf = przekaż do fzf
    # --height 40% = okno fzf zajmuje 40% wysokości terminala
    # --reverse = wyniki od góry do dołu (odwrotnie niż domyślnie)
    # --border = pokaż ramkę wokół fzf
    # --preview = pokaż podgląd dla wybranego elementu
    #   'ls -la {}' = pokaż zawartość katalogu (ls -la)
    #   {} = placeholder na wybrany element
    # --preview-window = konfiguracja okna podglądu
    #   right:50% = po prawej stronie, 50% szerokości
    local selected_project
    selected_project=$(echo "$projects_list" | fzf \
        --height 40% \
        --reverse \
        --border \
        --prompt "Projekt > " \
        --preview 'ls -la {}' \
        --preview-window right:50%)

    # Sprawdź czy użytkownik coś wybrał (czy nie anulował Escape/Ctrl+C)
    if [[ -z "$selected_project" ]]; then
        # Pusty wybór = użytkownik anulował
        echo "Anulowano wybór projektu" >&2
        exit 1
    fi

    # Zwróć wybrany projekt (stdout)
    echo "$selected_project"
}

# =============================================================================
# FUNKCJA: launch_project
# =============================================================================
# Uruchamia projekt w wybranym trybie.
# Wywołuje skrypt launch-project.sh z odpowiednimi parametrami.
#
# Argumenty:
#   $1 - Ścieżka do projektu
#   $2 - Tryb uruchomienia
# =============================================================================
launch_project() {
    local project_path="$1"  # Pierwsz argument = ścieżka
    local mode="$2"          # Drugi argument = tryb

    # Sprawdź czy skrypt launch-project.sh istnieje
    if [[ ! -f "$LAUNCH_PROJECT_SCRIPT" ]]; then
        echo "BŁĄD: Nie znaleziono skryptu: $LAUNCH_PROJECT_SCRIPT" >&2
        exit 1
    fi

    # Nadaj uprawnienia wykonywania
    chmod +x "$LAUNCH_PROJECT_SCRIPT"

    # Wywołaj skrypt uruchamiający projekt
    # "$LAUNCH_PROJECT_SCRIPT" = ścieżka do skryptu
    # "$project_path" = argument 1 (ścieżka)
    # "$mode" = argument 2 (tryb)
    "$LAUNCH_PROJECT_SCRIPT" "$project_path" "$mode"
}

# =============================================================================
# MAIN - Główna logika programu
# =============================================================================

main() {
    # Wypisz nagłówek
    echo "==================================" >&2
    echo "   Project Launcher" >&2
    echo "==================================" >&2
    echo "" >&2

    # 1. Sprawdź czy wszystkie wymagane narzędzia są zainstalowane
    check_dependencies

    # 2. Wybierz projekt i tryb
    # Jeśli użytkownik podał projekt jako argument, użyj go
    # W przeciwnym razie pokaż fzf do wyboru
    local project_path
    local mode

    if [[ $# -gt 0 ]]; then
        # Użytkownik podał argument - użyj go jako ścieżki projektu
        project_path="$1"

        # Sprawdź czy podana ścieżka istnieje
        if [[ ! -d "$project_path" ]]; then
            echo "BŁĄD: Katalog '$project_path' nie istnieje" >&2
            exit 1
        fi

        echo "Użyto projektu z argumentu: $project_path" >&2

        # Sprawdź czy podano także tryb jako drugi argument
        if [[ $# -gt 1 ]]; then
            mode="$2"
            echo "Użyto trybu z argumentu: $mode" >&2
        else
            mode="$DEFAULT_MODE"
            echo "Użyto domyślnego trybu: $mode" >&2
        fi
    else
        # Brak argumentu - pokaż fzf
        project_path=$(select_project)
        mode="$DEFAULT_MODE"
        echo "Użyto domyślnego trybu: $mode" >&2
    fi

    echo "" >&2
    echo "Wybrany projekt: $project_path" >&2
    echo "Wybrany tryb: $mode" >&2
    echo "" >&2

    # 3. Uruchom projekt w wybranym trybie
    launch_project "$project_path" "$mode"

    # Sukces!
    echo "" >&2
    echo "==================================" >&2
    echo "   Gotowe! ✓" >&2
    echo "==================================" >&2
}

# Wywołaj funkcję main z wszystkimi argumentami przekazanymi do skryptu
# "$@" = wszystkie argumenty jako osobne stringi
main "$@"
